{"meta":{"version":1,"warehouse":"4.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/test-1.md","hash":"1eee37983474fdd868948f468e7fad7d9129a249","modified":1694858750828},{"_id":"source/about/index.md","hash":"eec40db76bb8f4e751eba78a28c37aab75b81007","modified":1722413771923},{"_id":"source/_posts/test.md","hash":"dec90674bd1ba1a214fe87f6baadfb5c69a97759","modified":1694859499846},{"_id":"source/_posts/zhuhai.md","hash":"ce64a7736ed95f2f522a6e9cca7d7b70e747364e","modified":1694858750828},{"_id":"source/study/js创建对象的方法.md","hash":"0e9822dd9ea97217f7f4e4e0274d2e62decb1146","modified":1694858750837},{"_id":"source/摄影/index.md","hash":"03153ce2e6048434fff0bb000fa874b54cb2222b","modified":1694859468083},{"_id":"source/study/Javascript/Reduce.md","hash":"6b36ff39d708ad6ab9cc4be7ef616854a8549e38","modified":1694858750834},{"_id":"source/study/Javascript/js创建对象的方法.md","hash":"b505743a06a42f53dd202c828c75890b8ea1e639","modified":1694858750837},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1694858939100},{"_id":"node_modules/hexo-theme-fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1694858936697},{"_id":"node_modules/hexo-theme-fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1694858938375},{"_id":"node_modules/hexo-theme-fluid/_config.yml","hash":"ebe26856c4cc286df3181136b5b391dd2e5f5ec7","modified":1694858939170},{"_id":"node_modules/hexo-theme-fluid/package.json","hash":"0bc354a01c5e6e9de43bf67456dc16c59d400139","modified":1694858938358},{"_id":"node_modules/hexo-theme-fluid/layout/.DS_Store","hash":"e2295dbe42d85b294e6f3aeefaf3623bd31759ed","modified":1694858936312},{"_id":"node_modules/hexo-theme-fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1694858936755},{"_id":"node_modules/hexo-theme-fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1694858936779},{"_id":"node_modules/hexo-theme-fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1694858936944},{"_id":"node_modules/hexo-theme-fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1694858937009},{"_id":"node_modules/hexo-theme-fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1694858937067},{"_id":"node_modules/hexo-theme-fluid/layout/index.ejs","hash":"b15d13877827e99e0ff783a6b13b13cca90bfe8c","modified":1694858937272},{"_id":"node_modules/hexo-theme-fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1694858937281},{"_id":"node_modules/hexo-theme-fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1694858937288},{"_id":"node_modules/hexo-theme-fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1694858937403},{"_id":"node_modules/hexo-theme-fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1694858937418},{"_id":"node_modules/hexo-theme-fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1694858937534},{"_id":"node_modules/hexo-theme-fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1694858937544},{"_id":"node_modules/hexo-theme-fluid/scripts/.DS_Store","hash":"daec53fd4601c37ca272321ba2eb594d9b0a43ac","modified":1694858936355},{"_id":"node_modules/hexo-theme-fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1694858939203},{"_id":"node_modules/hexo-theme-fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1694858939222},{"_id":"node_modules/hexo-theme-fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1694858939238},{"_id":"node_modules/hexo-theme-fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1694858939255},{"_id":"node_modules/hexo-theme-fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1694858939265},{"_id":"node_modules/hexo-theme-fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1694858939271},{"_id":"node_modules/hexo-theme-fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1694858939282},{"_id":"node_modules/hexo-theme-fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1694858939297},{"_id":"node_modules/hexo-theme-fluid/source/.DS_Store","hash":"e11e97632e6d13d5b9dccadcc514268f3c039508","modified":1694858936591},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1694858936892},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1694858937045},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1694858937058},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1694858937110},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1694858937144},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1694858937191},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/head.ejs","hash":"776949aa697dffd54e9b1957d9245028879509a3","modified":1694858937224},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1694858937240},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1694858937334},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1694858937407},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1694858937453},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1694858937473},{"_id":"node_modules/hexo-theme-fluid/scripts/events/.DS_Store","hash":"80308812974d7cb7e001cd8f64ff9fced30ff139","modified":1694858936429},{"_id":"node_modules/hexo-theme-fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1694858937834},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1694858937749},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1694858937907},{"_id":"node_modules/hexo-theme-fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1694858938154},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1694858937897},{"_id":"node_modules/hexo-theme-fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1694858937954},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1694858937730},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1694858937750},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1694858937773},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1694858937852},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1694858937826},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1694858937946},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1694858938218},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1694858938245},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1694858938257},{"_id":"node_modules/hexo-theme-fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1694858938337},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1694858937659},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1694858937789},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1694858937859},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1694858937669},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1694858937925},{"_id":"node_modules/hexo-theme-fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1694858937934},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1694858937702},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1694858937941},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1694858938193},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1694858936492},{"_id":"node_modules/hexo-theme-fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1694858938235},{"_id":"node_modules/hexo-theme-fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1694858936733},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1694858938905},{"_id":"node_modules/hexo-theme-fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1694858938912},{"_id":"node_modules/hexo-theme-fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1694858938943},{"_id":"node_modules/hexo-theme-fluid/source/js/boot.js","hash":"2848f8eb5081a7f0550fbd76dc06d3ff877f1913","modified":1694858937654},{"_id":"node_modules/hexo-theme-fluid/source/js/color-schema.js","hash":"ba63f7c3324bc1fdd050a90add9d8faaffc27e07","modified":1694858937691},{"_id":"node_modules/hexo-theme-fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1694858937765},{"_id":"node_modules/hexo-theme-fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1694858937820},{"_id":"node_modules/hexo-theme-fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1694858937882},{"_id":"node_modules/hexo-theme-fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1694858937902},{"_id":"node_modules/hexo-theme-fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1694858938288},{"_id":"node_modules/hexo-theme-fluid/source/js/plugins.js","hash":"2333494add51e5e1374602a4e81f0be36a05d4c2","modified":1694858937962},{"_id":"node_modules/hexo-theme-fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1694858939156},{"_id":"node_modules/hexo-theme-fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1694858938395},{"_id":"node_modules/hexo-theme-fluid/source/img/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1694858936648},{"_id":"node_modules/hexo-theme-fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1694858937644},{"_id":"node_modules/hexo-theme-fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1694858938555},{"_id":"node_modules/hexo-theme-fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1694858938564},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1694858937085},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1694858937159},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1694858937150},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1694858937199},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1694858937216},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1694858937321},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1694858937428},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1694858937577},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1694858937594},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1694858937605},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1694858937626},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1694858936985},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1694858937524},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1694858936969},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1694858937387},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1694858936820},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1694858936836},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1694858937100},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/encrypt.ejs","hash":"cbcf6905f4990a22895a848e29dd4c05592a9043","modified":1694858937166},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1694858937175},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1694858937256},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/math.ejs","hash":"94c1ce6e312932e876886ba24b082ae34515a038","modified":1694858937345},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1694858937351},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1694858937395},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1694858937586},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1694858937027},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1694858937363},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/copyright.ejs","hash":"e74fb49526ddb14fee2c6360a560d17f57262ef7","modified":1694858937131},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1694858937371},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1694858937494},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1694858937513},{"_id":"node_modules/hexo-theme-fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1694858937570},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1694858937716},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1694858937784},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1694858937800},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1694858937806},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1694858937839},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1694858937872},{"_id":"node_modules/hexo-theme-fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1694858937920},{"_id":"node_modules/hexo-theme-fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1694858938666},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1694858939029},{"_id":"node_modules/hexo-theme-fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1694858938672},{"_id":"node_modules/hexo-theme-fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1694858938688},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1694858938582},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1694858938680},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1694858938851},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1694858938927},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1694858938927},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1694858938746},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1694858938755},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1694858938918},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1694858938800},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1694858939107},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1694858938869},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/highlight.styl","hash":"7054d79c9d5966fc57baf0adcdf3b19275987b62","modified":1694858938911},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1694858939046},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1694858938968},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1694858939064},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1694858938647},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1694858938941},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1694858938626},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1694858938656},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1694858938714},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1694858938880},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1694858938811},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1694858938884},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1694858938892},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1694858938901},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1694858938976},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1694858938988},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1694858938983},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1694858939038},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1694858939086},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1694858939074},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1694858939095},{"_id":"node_modules/hexo-theme-fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1694858939135},{"_id":"node_modules/hexo-theme-fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1694858938547},{"_id":"source/study/index.md","hash":"1a4d9510c97ca225fb932e90b12da02574fdd232","modified":1722413655171}],"Category":[{"name":"日记","_id":"clmlv9h890006cwun515v98io"}],"Data":[],"Page":[{"title":"白无意","date":"2022-07-14T02:51:03.000Z","_content":"### 我是谁？\n    白无意，取自于我初中高中时期喜欢的一系列经营游戏--开罗，在游戏中想要获胜就要成为第一，因此给自己命名为br1，br是我的姓名两个字的缩写。\n    br1nosense就是想要让自己去做一些有意义的事情。\n    故取中文白无意。\n### 联系\n    微信：Hey_baiwuyi\n    QQ ：963015343\n    邮箱：963015343@qq.com\n    github:[br1](https://github.com/br1nosense)\n    gitee:https://gitee.com/br1nosesne\n    b站：白无意丶","source":"about/index.md","raw":"title: 白无意\ndate: 2022-07-14 10:51:03\n---\n### 我是谁？\n    白无意，取自于我初中高中时期喜欢的一系列经营游戏--开罗，在游戏中想要获胜就要成为第一，因此给自己命名为br1，br是我的姓名两个字的缩写。\n    br1nosense就是想要让自己去做一些有意义的事情。\n    故取中文白无意。\n### 联系\n    微信：Hey_baiwuyi\n    QQ ：963015343\n    邮箱：963015343@qq.com\n    github:[br1](https://github.com/br1nosense)\n    gitee:https://gitee.com/br1nosesne\n    b站：白无意丶","updated":"2024-07-31T08:16:11.923Z","path":"about/index.html","_id":"clmlv9h7m0000cwun64m6e3ki","comments":1,"layout":"page","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h3 id=\"我是谁？\"><a href=\"#我是谁？\" class=\"headerlink\" title=\"我是谁？\"></a>我是谁？</h3><pre><code class=\"hljs\">白无意，取自于我初中高中时期喜欢的一系列经营游戏--开罗，在游戏中想要获胜就要成为第一，因此给自己命名为br1，br是我的姓名两个字的缩写。\nbr1nosense就是想要让自己去做一些有意义的事情。\n故取中文白无意。\n</code></pre>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><pre><code class=\"hljs\">微信：Hey_baiwuyi\nQQ ：963015343\n邮箱：963015343@qq.com\ngithub:[br1](https://github.com/br1nosense)\ngitee:https://gitee.com/br1nosesne\nb站：白无意丶\n</code></pre>\n","site":{"data":{}},"wordcount":241,"excerpt":"","more":"<h3 id=\"我是谁？\"><a href=\"#我是谁？\" class=\"headerlink\" title=\"我是谁？\"></a>我是谁？</h3><pre><code>白无意，取自于我初中高中时期喜欢的一系列经营游戏--开罗，在游戏中想要获胜就要成为第一，因此给自己命名为br1，br是我的姓名两个字的缩写。\nbr1nosense就是想要让自己去做一些有意义的事情。\n故取中文白无意。\n</code></pre>\n<h3 id=\"联系\"><a href=\"#联系\" class=\"headerlink\" title=\"联系\"></a>联系</h3><pre><code>微信：Hey_baiwuyi\nQQ ：963015343\n邮箱：963015343@qq.com\ngithub:[br1](https://github.com/br1nosense)\ngitee:https://gitee.com/br1nosesne\nb站：白无意丶\n</code></pre>\n"},{"title":"niahsdaa","date":"2022-07-14T05:30:51.000Z","_content":"\n# Object\n## hasOwnProperty方法\n### 作用：\n    Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n### 运用    \n    //1.判断自身属性是否存在\n    var o = new Object();\n    o.prop = 'exists';\n\n    function changeO() {\n    o.newprop = o.prop;\n    delete o.prop;\n    }\n\n    o.hasOwnProperty('prop');  // true\n    changeO();\n    o.hasOwnProperty('prop');  // false\n\n#### 2. 判断自身属性与继承属性\n    //自身属性为真，继承属性为假\n    function foo() {\n    this.name = 'foo'\n    this.sayHi = function () {\n        console.log('Say Hi')\n    }\n    }\n\n    foo.prototype.sayGoodBy = function () {\n    console.log('Say Good By')\n    }\n\n    let myPro = new foo()\n\n    console.log(myPro.name) // foo\n    console.log(myPro.hasOwnProperty('name')) // true\n    console.log(myPro.hasOwnProperty('toString')) // false\n    console.log(myPro.hasOwnProperty('hasOwnProperty')) // fasle\n    console.log(myPro.hasOwnProperty('sayHi')) // true\n    console.log(myPro.hasOwnProperty('sayGoodBy')) // false\n    console.log('sayGoodBy' in myPro) // true\n\n## Array.reduce方法\n### 作用：\n    计算数组元素相加后的总和\n    常用于数组去重、构建对象、数组扁平化、求和、统计等\n\n### 运用\n    Array.reduce((did,cur,index,arr) => {} , initVal)\n    did：累计器（操作后的结果）\n    cur：当前值\n    index：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\n    arr：数组本身\n\n### 实例\n#### 1.求和\n    let arr = [1,2,3,4]\n    let sum = arr.reduce((did,cur)=>{\n        did += cur;\n        return did;\n    })\n#### 2.次数统计\n    let arr = ['a','a','a','b']\n    let sum = arr.reduce((did,cur)=>{\n      if(!did.hasOwnProperty(cur)){\n            did[cur] =1\n      }else{\n        did[cur] ++ \n      }\n      return did;\n    })\n#### 3.分组累加\n    const arr = [\n    {count: 10, weight: 1, height: 2},\n    {count: 20, weight: 2, height: 4},\n    {count: 30, weight: 3, height: 6}];\n    let sum =arr.reduce((did,cur)=>{\n        for(let key in cur){\n            if(!did.hasOwnProperty(key)){\n                did[key] = 0\n            }else{\n                did[key]+=cur[key]\n            }\n        }\n    })\n#### 4.二位数组转化为一维数组\n    let arr = [1,2,[3,4,5],6,[7,8,9]];\n    let sum =arr.reduce((did,cur)=>{\n        return did.concat(cur)\n    },[])\n#### 5.数组去重\n    let arr = [1,2,2,3,3,3]\n    let sum = arr.reduce((did,cur)=>{\n        if(!did.includes(cur)){\n            did.push(cur)\n        }\n        return did \n    },[])","source":"study/js创建对象的方法.md","raw":"---\ntitle: niahsdaa \ndate: 2022-07-14 13:30:51\n---\n\n# Object\n## hasOwnProperty方法\n### 作用：\n    Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n### 运用    \n    //1.判断自身属性是否存在\n    var o = new Object();\n    o.prop = 'exists';\n\n    function changeO() {\n    o.newprop = o.prop;\n    delete o.prop;\n    }\n\n    o.hasOwnProperty('prop');  // true\n    changeO();\n    o.hasOwnProperty('prop');  // false\n\n#### 2. 判断自身属性与继承属性\n    //自身属性为真，继承属性为假\n    function foo() {\n    this.name = 'foo'\n    this.sayHi = function () {\n        console.log('Say Hi')\n    }\n    }\n\n    foo.prototype.sayGoodBy = function () {\n    console.log('Say Good By')\n    }\n\n    let myPro = new foo()\n\n    console.log(myPro.name) // foo\n    console.log(myPro.hasOwnProperty('name')) // true\n    console.log(myPro.hasOwnProperty('toString')) // false\n    console.log(myPro.hasOwnProperty('hasOwnProperty')) // fasle\n    console.log(myPro.hasOwnProperty('sayHi')) // true\n    console.log(myPro.hasOwnProperty('sayGoodBy')) // false\n    console.log('sayGoodBy' in myPro) // true\n\n## Array.reduce方法\n### 作用：\n    计算数组元素相加后的总和\n    常用于数组去重、构建对象、数组扁平化、求和、统计等\n\n### 运用\n    Array.reduce((did,cur,index,arr) => {} , initVal)\n    did：累计器（操作后的结果）\n    cur：当前值\n    index：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\n    arr：数组本身\n\n### 实例\n#### 1.求和\n    let arr = [1,2,3,4]\n    let sum = arr.reduce((did,cur)=>{\n        did += cur;\n        return did;\n    })\n#### 2.次数统计\n    let arr = ['a','a','a','b']\n    let sum = arr.reduce((did,cur)=>{\n      if(!did.hasOwnProperty(cur)){\n            did[cur] =1\n      }else{\n        did[cur] ++ \n      }\n      return did;\n    })\n#### 3.分组累加\n    const arr = [\n    {count: 10, weight: 1, height: 2},\n    {count: 20, weight: 2, height: 4},\n    {count: 30, weight: 3, height: 6}];\n    let sum =arr.reduce((did,cur)=>{\n        for(let key in cur){\n            if(!did.hasOwnProperty(key)){\n                did[key] = 0\n            }else{\n                did[key]+=cur[key]\n            }\n        }\n    })\n#### 4.二位数组转化为一维数组\n    let arr = [1,2,[3,4,5],6,[7,8,9]];\n    let sum =arr.reduce((did,cur)=>{\n        return did.concat(cur)\n    },[])\n#### 5.数组去重\n    let arr = [1,2,2,3,3,3]\n    let sum = arr.reduce((did,cur)=>{\n        if(!did.includes(cur)){\n            did.push(cur)\n        }\n        return did \n    },[])","updated":"2023-09-16T10:05:50.837Z","path":"study/js创建对象的方法.html","comments":1,"layout":"page","_id":"clmlv9h800002cwungvtu3ujw","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"hasOwnProperty方法\"><a href=\"#hasOwnProperty方法\" class=\"headerlink\" title=\"hasOwnProperty方法\"></a>hasOwnProperty方法</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code class=\"hljs\">Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"运用\"><a href=\"#运用\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code class=\"hljs\">//1.判断自身属性是否存在\nvar o = new Object();\no.prop = &#39;exists&#39;;\n\nfunction changeO() &#123;\no.newprop = o.prop;\ndelete o.prop;\n&#125;\n\no.hasOwnProperty(&#39;prop&#39;);  // true\nchangeO();\no.hasOwnProperty(&#39;prop&#39;);  // false\n</code></pre>\n<h4 id=\"2-判断自身属性与继承属性\"><a href=\"#2-判断自身属性与继承属性\" class=\"headerlink\" title=\"2. 判断自身属性与继承属性\"></a>2. 判断自身属性与继承属性</h4><pre><code class=\"hljs\">//自身属性为真，继承属性为假\nfunction foo() &#123;\nthis.name = &#39;foo&#39;\nthis.sayHi = function () &#123;\n    console.log(&#39;Say Hi&#39;)\n&#125;\n&#125;\n\nfoo.prototype.sayGoodBy = function () &#123;\nconsole.log(&#39;Say Good By&#39;)\n&#125;\n\nlet myPro = new foo()\n\nconsole.log(myPro.name) // foo\nconsole.log(myPro.hasOwnProperty(&#39;name&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;toString&#39;)) // false\nconsole.log(myPro.hasOwnProperty(&#39;hasOwnProperty&#39;)) // fasle\nconsole.log(myPro.hasOwnProperty(&#39;sayHi&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;sayGoodBy&#39;)) // false\nconsole.log(&#39;sayGoodBy&#39; in myPro) // true\n</code></pre>\n<h2 id=\"Array-reduce方法\"><a href=\"#Array-reduce方法\" class=\"headerlink\" title=\"Array.reduce方法\"></a>Array.reduce方法</h2><h3 id=\"作用：-1\"><a href=\"#作用：-1\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code class=\"hljs\">计算数组元素相加后的总和\n常用于数组去重、构建对象、数组扁平化、求和、统计等\n</code></pre>\n<h3 id=\"运用-1\"><a href=\"#运用-1\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code class=\"hljs\">Array.reduce((did,cur,index,arr) =&gt; &#123;&#125; , initVal)\ndid：累计器（操作后的结果）\ncur：当前值\nindex：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\narr：数组本身\n</code></pre>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><h4 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h4><pre><code class=\"hljs\">let arr = [1,2,3,4]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    did += cur;\n    return did;\n&#125;)\n</code></pre>\n<h4 id=\"2-次数统计\"><a href=\"#2-次数统计\" class=\"headerlink\" title=\"2.次数统计\"></a>2.次数统计</h4><pre><code class=\"hljs\">let arr = [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n  if(!did.hasOwnProperty(cur))&#123;\n        did[cur] =1\n  &#125;else&#123;\n    did[cur] ++ \n  &#125;\n  return did;\n&#125;)\n</code></pre>\n<h4 id=\"3-分组累加\"><a href=\"#3-分组累加\" class=\"headerlink\" title=\"3.分组累加\"></a>3.分组累加</h4><pre><code class=\"hljs\">const arr = [\n&#123;count: 10, weight: 1, height: 2&#125;,\n&#123;count: 20, weight: 2, height: 4&#125;,\n&#123;count: 30, weight: 3, height: 6&#125;];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    for(let key in cur)&#123;\n        if(!did.hasOwnProperty(key))&#123;\n            did[key] = 0\n        &#125;else&#123;\n            did[key]+=cur[key]\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h4 id=\"4-二位数组转化为一维数组\"><a href=\"#4-二位数组转化为一维数组\" class=\"headerlink\" title=\"4.二位数组转化为一维数组\"></a>4.二位数组转化为一维数组</h4><pre><code class=\"hljs\">let arr = [1,2,[3,4,5],6,[7,8,9]];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    return did.concat(cur)\n&#125;,[])\n</code></pre>\n<h4 id=\"5-数组去重\"><a href=\"#5-数组去重\" class=\"headerlink\" title=\"5.数组去重\"></a>5.数组去重</h4><pre><code class=\"hljs\">let arr = [1,2,2,3,3,3]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    if(!did.includes(cur))&#123;\n        did.push(cur)\n    &#125;\n    return did \n&#125;,[])\n</code></pre>\n","site":{"data":{}},"wordcount":1879,"excerpt":"","more":"<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"hasOwnProperty方法\"><a href=\"#hasOwnProperty方法\" class=\"headerlink\" title=\"hasOwnProperty方法\"></a>hasOwnProperty方法</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code>Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"运用\"><a href=\"#运用\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code>//1.判断自身属性是否存在\nvar o = new Object();\no.prop = &#39;exists&#39;;\n\nfunction changeO() &#123;\no.newprop = o.prop;\ndelete o.prop;\n&#125;\n\no.hasOwnProperty(&#39;prop&#39;);  // true\nchangeO();\no.hasOwnProperty(&#39;prop&#39;);  // false\n</code></pre>\n<h4 id=\"2-判断自身属性与继承属性\"><a href=\"#2-判断自身属性与继承属性\" class=\"headerlink\" title=\"2. 判断自身属性与继承属性\"></a>2. 判断自身属性与继承属性</h4><pre><code>//自身属性为真，继承属性为假\nfunction foo() &#123;\nthis.name = &#39;foo&#39;\nthis.sayHi = function () &#123;\n    console.log(&#39;Say Hi&#39;)\n&#125;\n&#125;\n\nfoo.prototype.sayGoodBy = function () &#123;\nconsole.log(&#39;Say Good By&#39;)\n&#125;\n\nlet myPro = new foo()\n\nconsole.log(myPro.name) // foo\nconsole.log(myPro.hasOwnProperty(&#39;name&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;toString&#39;)) // false\nconsole.log(myPro.hasOwnProperty(&#39;hasOwnProperty&#39;)) // fasle\nconsole.log(myPro.hasOwnProperty(&#39;sayHi&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;sayGoodBy&#39;)) // false\nconsole.log(&#39;sayGoodBy&#39; in myPro) // true\n</code></pre>\n<h2 id=\"Array-reduce方法\"><a href=\"#Array-reduce方法\" class=\"headerlink\" title=\"Array.reduce方法\"></a>Array.reduce方法</h2><h3 id=\"作用：-1\"><a href=\"#作用：-1\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code>计算数组元素相加后的总和\n常用于数组去重、构建对象、数组扁平化、求和、统计等\n</code></pre>\n<h3 id=\"运用-1\"><a href=\"#运用-1\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code>Array.reduce((did,cur,index,arr) =&gt; &#123;&#125; , initVal)\ndid：累计器（操作后的结果）\ncur：当前值\nindex：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\narr：数组本身\n</code></pre>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><h4 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h4><pre><code>let arr = [1,2,3,4]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    did += cur;\n    return did;\n&#125;)\n</code></pre>\n<h4 id=\"2-次数统计\"><a href=\"#2-次数统计\" class=\"headerlink\" title=\"2.次数统计\"></a>2.次数统计</h4><pre><code>let arr = [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n  if(!did.hasOwnProperty(cur))&#123;\n        did[cur] =1\n  &#125;else&#123;\n    did[cur] ++ \n  &#125;\n  return did;\n&#125;)\n</code></pre>\n<h4 id=\"3-分组累加\"><a href=\"#3-分组累加\" class=\"headerlink\" title=\"3.分组累加\"></a>3.分组累加</h4><pre><code>const arr = [\n&#123;count: 10, weight: 1, height: 2&#125;,\n&#123;count: 20, weight: 2, height: 4&#125;,\n&#123;count: 30, weight: 3, height: 6&#125;];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    for(let key in cur)&#123;\n        if(!did.hasOwnProperty(key))&#123;\n            did[key] = 0\n        &#125;else&#123;\n            did[key]+=cur[key]\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h4 id=\"4-二位数组转化为一维数组\"><a href=\"#4-二位数组转化为一维数组\" class=\"headerlink\" title=\"4.二位数组转化为一维数组\"></a>4.二位数组转化为一维数组</h4><pre><code>let arr = [1,2,[3,4,5],6,[7,8,9]];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    return did.concat(cur)\n&#125;,[])\n</code></pre>\n<h4 id=\"5-数组去重\"><a href=\"#5-数组去重\" class=\"headerlink\" title=\"5.数组去重\"></a>5.数组去重</h4><pre><code>let arr = [1,2,2,3,3,3]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    if(!did.includes(cur))&#123;\n        did.push(cur)\n    &#125;\n    return did \n&#125;,[])\n</code></pre>\n"},{"title":"摄影","date":"2022-07-14T05:30:51.000Z","_content":"\n你好","source":"摄影/index.md","raw":"---\ntitle: 摄影\ndate: 2022-07-14 13:30:51\n---\n\n你好","updated":"2023-09-16T10:17:48.083Z","path":"摄影/index.html","_id":"clmlv9h840004cwun1wkbh4hl","comments":1,"layout":"page","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>你好</p>\n","site":{"data":{}},"wordcount":2,"excerpt":"","more":"<p>你好</p>\n"},{"_content":"title: 杂记\nauthor: 白无意\ntags:\n  - Javascript\ncategories:\n  - Javascript\ndate: 2022-8-05\n\n# Object\n## hasOwnProperty方法\n### 作用：\n    Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n### 运用    \n    //1.判断自身属性是否存在\n    var o = new Object();\n    o.prop = 'exists';\n\n    function changeO() {\n    o.newprop = o.prop;\n    delete o.prop;\n    }\n\n    o.hasOwnProperty('prop');  // true\n    changeO();\n    o.hasOwnProperty('prop');  // false\n\n#### 2. 判断自身属性与继承属性\n    //自身属性为真，继承属性为假\n    function foo() {\n    this.name = 'foo'\n    this.sayHi = function () {\n        console.log('Say Hi')\n    }\n    }\n\n    foo.prototype.sayGoodBy = function () {\n    console.log('Say Good By')\n    }\n\n    let myPro = new foo()\n\n    console.log(myPro.name) // foo\n    console.log(myPro.hasOwnProperty('name')) // true\n    console.log(myPro.hasOwnProperty('toString')) // false\n    console.log(myPro.hasOwnProperty('hasOwnProperty')) // fasle\n    console.log(myPro.hasOwnProperty('sayHi')) // true\n    console.log(myPro.hasOwnProperty('sayGoodBy')) // false\n    console.log('sayGoodBy' in myPro) // true\n\n## Array.reduce方法\n### 作用：\n    计算数组元素相加后的总和\n    常用于数组去重、构建对象、数组扁平化、求和、统计等\n\n### 运用\n    Array.reduce((did,cur,index,arr) => {} , initVal)\n    did：累计器（操作后的结果）\n    cur：当前值\n    index：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\n    arr：数组本身\n\n### 实例\n#### 1.求和\n    let arr = [1,2,3,4]\n    let sum = arr.reduce((did,cur)=>{\n        did += cur;\n        return did;\n    })\n#### 2.次数统计\n    let arr = ['a','a','a','b']\n    let sum = arr.reduce((did,cur)=>{\n      if(!did.hasOwnProperty(cur)){\n            did[cur] =1\n      }else{\n        did[cur] ++ \n      }\n      return did;\n    })\n#### 3.分组累加\n    const arr = [\n    {count: 10, weight: 1, height: 2},\n    {count: 20, weight: 2, height: 4},\n    {count: 30, weight: 3, height: 6}];\n    let sum =arr.reduce((did,cur)=>{\n        for(let key in cur){\n            if(!did.hasOwnProperty(key)){\n                did[key] = 0\n            }else{\n                did[key]+=cur[key]\n            }\n        }\n    })\n#### 4.二位数组转化为一维数组\n    let arr = [1,2,[3,4,5],6,[7,8,9]];\n    let sum =arr.reduce((did,cur)=>{\n        return did.concat(cur)\n    },[])\n#### 5.数组去重\n    let arr = [1,2,2,3,3,3]\n    let sum = arr.reduce((did,cur)=>{\n        if(!did.includes(cur)){\n            did.push(cur)\n        }\n        return did \n    },[])","source":"study/Javascript/Reduce.md","raw":"title: 杂记\nauthor: 白无意\ntags:\n  - Javascript\ncategories:\n  - Javascript\ndate: 2022-8-05\n\n# Object\n## hasOwnProperty方法\n### 作用：\n    Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n### 运用    \n    //1.判断自身属性是否存在\n    var o = new Object();\n    o.prop = 'exists';\n\n    function changeO() {\n    o.newprop = o.prop;\n    delete o.prop;\n    }\n\n    o.hasOwnProperty('prop');  // true\n    changeO();\n    o.hasOwnProperty('prop');  // false\n\n#### 2. 判断自身属性与继承属性\n    //自身属性为真，继承属性为假\n    function foo() {\n    this.name = 'foo'\n    this.sayHi = function () {\n        console.log('Say Hi')\n    }\n    }\n\n    foo.prototype.sayGoodBy = function () {\n    console.log('Say Good By')\n    }\n\n    let myPro = new foo()\n\n    console.log(myPro.name) // foo\n    console.log(myPro.hasOwnProperty('name')) // true\n    console.log(myPro.hasOwnProperty('toString')) // false\n    console.log(myPro.hasOwnProperty('hasOwnProperty')) // fasle\n    console.log(myPro.hasOwnProperty('sayHi')) // true\n    console.log(myPro.hasOwnProperty('sayGoodBy')) // false\n    console.log('sayGoodBy' in myPro) // true\n\n## Array.reduce方法\n### 作用：\n    计算数组元素相加后的总和\n    常用于数组去重、构建对象、数组扁平化、求和、统计等\n\n### 运用\n    Array.reduce((did,cur,index,arr) => {} , initVal)\n    did：累计器（操作后的结果）\n    cur：当前值\n    index：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\n    arr：数组本身\n\n### 实例\n#### 1.求和\n    let arr = [1,2,3,4]\n    let sum = arr.reduce((did,cur)=>{\n        did += cur;\n        return did;\n    })\n#### 2.次数统计\n    let arr = ['a','a','a','b']\n    let sum = arr.reduce((did,cur)=>{\n      if(!did.hasOwnProperty(cur)){\n            did[cur] =1\n      }else{\n        did[cur] ++ \n      }\n      return did;\n    })\n#### 3.分组累加\n    const arr = [\n    {count: 10, weight: 1, height: 2},\n    {count: 20, weight: 2, height: 4},\n    {count: 30, weight: 3, height: 6}];\n    let sum =arr.reduce((did,cur)=>{\n        for(let key in cur){\n            if(!did.hasOwnProperty(key)){\n                did[key] = 0\n            }else{\n                did[key]+=cur[key]\n            }\n        }\n    })\n#### 4.二位数组转化为一维数组\n    let arr = [1,2,[3,4,5],6,[7,8,9]];\n    let sum =arr.reduce((did,cur)=>{\n        return did.concat(cur)\n    },[])\n#### 5.数组去重\n    let arr = [1,2,2,3,3,3]\n    let sum = arr.reduce((did,cur)=>{\n        if(!did.includes(cur)){\n            did.push(cur)\n        }\n        return did \n    },[])","date":"2023-09-16T10:05:50.834Z","updated":"2023-09-16T10:05:50.834Z","path":"study/Javascript/Reduce.html","title":"","comments":1,"layout":"page","_id":"clmlv9h8c0008cwun40ft3plg","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>title: 杂记<br>author: 白无意<br>tags:</p>\n<ul>\n<li>Javascript<br>categories:</li>\n<li>Javascript<br>date: 2022-8-05</li>\n</ul>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"hasOwnProperty方法\"><a href=\"#hasOwnProperty方法\" class=\"headerlink\" title=\"hasOwnProperty方法\"></a>hasOwnProperty方法</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code class=\"hljs\">Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"运用\"><a href=\"#运用\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code class=\"hljs\">//1.判断自身属性是否存在\nvar o = new Object();\no.prop = &#39;exists&#39;;\n\nfunction changeO() &#123;\no.newprop = o.prop;\ndelete o.prop;\n&#125;\n\no.hasOwnProperty(&#39;prop&#39;);  // true\nchangeO();\no.hasOwnProperty(&#39;prop&#39;);  // false\n</code></pre>\n<h4 id=\"2-判断自身属性与继承属性\"><a href=\"#2-判断自身属性与继承属性\" class=\"headerlink\" title=\"2. 判断自身属性与继承属性\"></a>2. 判断自身属性与继承属性</h4><pre><code class=\"hljs\">//自身属性为真，继承属性为假\nfunction foo() &#123;\nthis.name = &#39;foo&#39;\nthis.sayHi = function () &#123;\n    console.log(&#39;Say Hi&#39;)\n&#125;\n&#125;\n\nfoo.prototype.sayGoodBy = function () &#123;\nconsole.log(&#39;Say Good By&#39;)\n&#125;\n\nlet myPro = new foo()\n\nconsole.log(myPro.name) // foo\nconsole.log(myPro.hasOwnProperty(&#39;name&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;toString&#39;)) // false\nconsole.log(myPro.hasOwnProperty(&#39;hasOwnProperty&#39;)) // fasle\nconsole.log(myPro.hasOwnProperty(&#39;sayHi&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;sayGoodBy&#39;)) // false\nconsole.log(&#39;sayGoodBy&#39; in myPro) // true\n</code></pre>\n<h2 id=\"Array-reduce方法\"><a href=\"#Array-reduce方法\" class=\"headerlink\" title=\"Array.reduce方法\"></a>Array.reduce方法</h2><h3 id=\"作用：-1\"><a href=\"#作用：-1\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code class=\"hljs\">计算数组元素相加后的总和\n常用于数组去重、构建对象、数组扁平化、求和、统计等\n</code></pre>\n<h3 id=\"运用-1\"><a href=\"#运用-1\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code class=\"hljs\">Array.reduce((did,cur,index,arr) =&gt; &#123;&#125; , initVal)\ndid：累计器（操作后的结果）\ncur：当前值\nindex：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\narr：数组本身\n</code></pre>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><h4 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h4><pre><code class=\"hljs\">let arr = [1,2,3,4]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    did += cur;\n    return did;\n&#125;)\n</code></pre>\n<h4 id=\"2-次数统计\"><a href=\"#2-次数统计\" class=\"headerlink\" title=\"2.次数统计\"></a>2.次数统计</h4><pre><code class=\"hljs\">let arr = [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n  if(!did.hasOwnProperty(cur))&#123;\n        did[cur] =1\n  &#125;else&#123;\n    did[cur] ++ \n  &#125;\n  return did;\n&#125;)\n</code></pre>\n<h4 id=\"3-分组累加\"><a href=\"#3-分组累加\" class=\"headerlink\" title=\"3.分组累加\"></a>3.分组累加</h4><pre><code class=\"hljs\">const arr = [\n&#123;count: 10, weight: 1, height: 2&#125;,\n&#123;count: 20, weight: 2, height: 4&#125;,\n&#123;count: 30, weight: 3, height: 6&#125;];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    for(let key in cur)&#123;\n        if(!did.hasOwnProperty(key))&#123;\n            did[key] = 0\n        &#125;else&#123;\n            did[key]+=cur[key]\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h4 id=\"4-二位数组转化为一维数组\"><a href=\"#4-二位数组转化为一维数组\" class=\"headerlink\" title=\"4.二位数组转化为一维数组\"></a>4.二位数组转化为一维数组</h4><pre><code class=\"hljs\">let arr = [1,2,[3,4,5],6,[7,8,9]];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    return did.concat(cur)\n&#125;,[])\n</code></pre>\n<h4 id=\"5-数组去重\"><a href=\"#5-数组去重\" class=\"headerlink\" title=\"5.数组去重\"></a>5.数组去重</h4><pre><code class=\"hljs\">let arr = [1,2,2,3,3,3]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    if(!did.includes(cur))&#123;\n        did.push(cur)\n    &#125;\n    return did \n&#125;,[])\n</code></pre>\n","site":{"data":{}},"wordcount":1947,"excerpt":"","more":"<p>title: 杂记<br>author: 白无意<br>tags:</p>\n<ul>\n<li>Javascript<br>categories:</li>\n<li>Javascript<br>date: 2022-8-05</li>\n</ul>\n<h1 id=\"Object\"><a href=\"#Object\" class=\"headerlink\" title=\"Object\"></a>Object</h1><h2 id=\"hasOwnProperty方法\"><a href=\"#hasOwnProperty方法\" class=\"headerlink\" title=\"hasOwnProperty方法\"></a>hasOwnProperty方法</h2><h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code>Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。\n</code></pre>\n<h3 id=\"运用\"><a href=\"#运用\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code>//1.判断自身属性是否存在\nvar o = new Object();\no.prop = &#39;exists&#39;;\n\nfunction changeO() &#123;\no.newprop = o.prop;\ndelete o.prop;\n&#125;\n\no.hasOwnProperty(&#39;prop&#39;);  // true\nchangeO();\no.hasOwnProperty(&#39;prop&#39;);  // false\n</code></pre>\n<h4 id=\"2-判断自身属性与继承属性\"><a href=\"#2-判断自身属性与继承属性\" class=\"headerlink\" title=\"2. 判断自身属性与继承属性\"></a>2. 判断自身属性与继承属性</h4><pre><code>//自身属性为真，继承属性为假\nfunction foo() &#123;\nthis.name = &#39;foo&#39;\nthis.sayHi = function () &#123;\n    console.log(&#39;Say Hi&#39;)\n&#125;\n&#125;\n\nfoo.prototype.sayGoodBy = function () &#123;\nconsole.log(&#39;Say Good By&#39;)\n&#125;\n\nlet myPro = new foo()\n\nconsole.log(myPro.name) // foo\nconsole.log(myPro.hasOwnProperty(&#39;name&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;toString&#39;)) // false\nconsole.log(myPro.hasOwnProperty(&#39;hasOwnProperty&#39;)) // fasle\nconsole.log(myPro.hasOwnProperty(&#39;sayHi&#39;)) // true\nconsole.log(myPro.hasOwnProperty(&#39;sayGoodBy&#39;)) // false\nconsole.log(&#39;sayGoodBy&#39; in myPro) // true\n</code></pre>\n<h2 id=\"Array-reduce方法\"><a href=\"#Array-reduce方法\" class=\"headerlink\" title=\"Array.reduce方法\"></a>Array.reduce方法</h2><h3 id=\"作用：-1\"><a href=\"#作用：-1\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><pre><code>计算数组元素相加后的总和\n常用于数组去重、构建对象、数组扁平化、求和、统计等\n</code></pre>\n<h3 id=\"运用-1\"><a href=\"#运用-1\" class=\"headerlink\" title=\"运用\"></a>运用</h3><pre><code>Array.reduce((did,cur,index,arr) =&gt; &#123;&#125; , initVal)\ndid：累计器（操作后的结果）\ncur：当前值\nindex：当前索引（如果有 initVal 索引从0开始，否侧从1开始）\narr：数组本身\n</code></pre>\n<h3 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h3><h4 id=\"1-求和\"><a href=\"#1-求和\" class=\"headerlink\" title=\"1.求和\"></a>1.求和</h4><pre><code>let arr = [1,2,3,4]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    did += cur;\n    return did;\n&#125;)\n</code></pre>\n<h4 id=\"2-次数统计\"><a href=\"#2-次数统计\" class=\"headerlink\" title=\"2.次数统计\"></a>2.次数统计</h4><pre><code>let arr = [&#39;a&#39;,&#39;a&#39;,&#39;a&#39;,&#39;b&#39;]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n  if(!did.hasOwnProperty(cur))&#123;\n        did[cur] =1\n  &#125;else&#123;\n    did[cur] ++ \n  &#125;\n  return did;\n&#125;)\n</code></pre>\n<h4 id=\"3-分组累加\"><a href=\"#3-分组累加\" class=\"headerlink\" title=\"3.分组累加\"></a>3.分组累加</h4><pre><code>const arr = [\n&#123;count: 10, weight: 1, height: 2&#125;,\n&#123;count: 20, weight: 2, height: 4&#125;,\n&#123;count: 30, weight: 3, height: 6&#125;];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    for(let key in cur)&#123;\n        if(!did.hasOwnProperty(key))&#123;\n            did[key] = 0\n        &#125;else&#123;\n            did[key]+=cur[key]\n        &#125;\n    &#125;\n&#125;)\n</code></pre>\n<h4 id=\"4-二位数组转化为一维数组\"><a href=\"#4-二位数组转化为一维数组\" class=\"headerlink\" title=\"4.二位数组转化为一维数组\"></a>4.二位数组转化为一维数组</h4><pre><code>let arr = [1,2,[3,4,5],6,[7,8,9]];\nlet sum =arr.reduce((did,cur)=&gt;&#123;\n    return did.concat(cur)\n&#125;,[])\n</code></pre>\n<h4 id=\"5-数组去重\"><a href=\"#5-数组去重\" class=\"headerlink\" title=\"5.数组去重\"></a>5.数组去重</h4><pre><code>let arr = [1,2,2,3,3,3]\nlet sum = arr.reduce((did,cur)=&gt;&#123;\n    if(!did.includes(cur))&#123;\n        did.push(cur)\n    &#125;\n    return did \n&#125;,[])\n</code></pre>\n"},{"_content":"title: 杂记\nauthor: 白无意\ntags:\n  - Javascript\ncategories:\n  - Javascript\ndate: 2022-8-05\n\n## js创建对象的方法\n\n我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js\n和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象\n创建方式，我了解到的方式有这么几种：\n\n### 1.工厂模式\n用函数来封装对象的细节\n\n优点：解决创建多个相似对象代码复用的问题\n\n缺点：没有解决对象识别问题（不知道这个对象是谁\n\n    function createPerson(name, age, job){\n        var o = new Object();\n        o.name = name;\n        o.age = age;\n        o.job = job;\n        o.sayName = function(){\n            alert(this.name);\n        };\n        return o;\n    }\n\n    var person1 = createPerson(\"james\"，9，\"student\");\n\n    var person2 = createPerson(\"kobe\"，9，\"student\");\n\n### 2.构造函数模式\n当我们使用构造函数实例化一个对象的时候，对象中会包含一个 __proto__ 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。\n\n优点：解决了对象类型无法识别的问题，\n缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。\n\n    function createPerson(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        alert(this.name);\n    };\n    return o;\n}\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    var person2 = new createPerson(\"kobe\"，9，\"student\");\n\n### 3.原型模式\n\n每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。\n\n优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。\n\n缺点：\n\n首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。\n\n因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。\n\n    function Person(){\n\n    }\n\n    Person.prototype.name = \"james\";\n    Person.prototype.age = 9;\n    Person.prototype.job = \"student\";\n    Person.prototype.sayName = function(){\n        alert(this.name);\n    }\n\n    var person1 = new Person();\n    person1.sayName(); // \"james\"\n\n    var person2 = new Person();\n    person2.sayName(); // \"james\"\n\n\n    console.log(person1.sayName === person2.sayName) // true\n\n### 4.组合使用构造函数模式和原型模式\n用构造函数船舰对象，原型模式创建方法\n\n优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。\n\n缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。\n\n    function Person(name, age, job){\n        this.name = name;\n        this.age = age;\n        this.job = job;\n    }\n\n    Person.prototype = {\n        constructor: Person,\n        sayName: function(){\n            alert(this.name);\n        }\n    }\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    var person2 = new createPerson(\"kobe\"，9，\"student\");\n\n    console.log(person1.name); // \"james\"\n    console.log(person2.name); // \"kobe\"\n    console.log(person1.sayName === person2.sayName); // true\n\n\n### 5.动态原型模式\n把所有信息都封装在构造函数里，通过判断只初始化一次原型\n\n优点：解决了混合模式中封装性的问题\n\n    function Person(name, age, job){\n        this.name = name;\n        this.age = age;\n        this.job = job;\n\n        if(typeof this.sayName !== \"function\" ){\n\n            Person.prototype.sayName: function(){\n                alert(this.name);\n            } \n        } \n    }\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    person1.sayName(); // \"james\"\n\n### 6.稳妥构造函数模式\n和工厂模式一样的创建，但是采用new操作符最后来创建对象\n\n优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。\n\n缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。\n\n    function Person(name, age, job){\n        var o = new Object();\n        o.name = name;\n        o.age = age;\n        o.job = job;\n        o.sayName = function(){\n            alert(this.name);\n        };\n        return o;\n    }\n\n    var person1 = new Person(\"james\"，9，\"student\");\n\n### 7.稳妥构造函数模式\n稳妥对象，既没有公共属性，而且其方法也不使用this的对象，比较封闭，防止数据修改\n\n优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。\n\n缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型\n\n    function Person(name, age, job){\n\n        //创建要返回的对象\n        var o = new Object();\n\n        //可以在这里定义私有变量和函数\n\n        //添加方法\n        o.sayName = function(){\n            console.log(this.name);\n        }\n\n        //返回对象\n        return o;\n    } \n\n    var person1 =  Person(\"james\"，9，\"student\");\n\n    person1.sayName(); // \"james\"","source":"study/Javascript/js创建对象的方法.md","raw":"title: 杂记\nauthor: 白无意\ntags:\n  - Javascript\ncategories:\n  - Javascript\ndate: 2022-8-05\n\n## js创建对象的方法\n\n我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js\n和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象\n创建方式，我了解到的方式有这么几种：\n\n### 1.工厂模式\n用函数来封装对象的细节\n\n优点：解决创建多个相似对象代码复用的问题\n\n缺点：没有解决对象识别问题（不知道这个对象是谁\n\n    function createPerson(name, age, job){\n        var o = new Object();\n        o.name = name;\n        o.age = age;\n        o.job = job;\n        o.sayName = function(){\n            alert(this.name);\n        };\n        return o;\n    }\n\n    var person1 = createPerson(\"james\"，9，\"student\");\n\n    var person2 = createPerson(\"kobe\"，9，\"student\");\n\n### 2.构造函数模式\n当我们使用构造函数实例化一个对象的时候，对象中会包含一个 __proto__ 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。\n\n优点：解决了对象类型无法识别的问题，\n缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。\n\n    function createPerson(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        alert(this.name);\n    };\n    return o;\n}\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    var person2 = new createPerson(\"kobe\"，9，\"student\");\n\n### 3.原型模式\n\n每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。\n\n优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。\n\n缺点：\n\n首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。\n\n因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。\n\n    function Person(){\n\n    }\n\n    Person.prototype.name = \"james\";\n    Person.prototype.age = 9;\n    Person.prototype.job = \"student\";\n    Person.prototype.sayName = function(){\n        alert(this.name);\n    }\n\n    var person1 = new Person();\n    person1.sayName(); // \"james\"\n\n    var person2 = new Person();\n    person2.sayName(); // \"james\"\n\n\n    console.log(person1.sayName === person2.sayName) // true\n\n### 4.组合使用构造函数模式和原型模式\n用构造函数船舰对象，原型模式创建方法\n\n优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。\n\n缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。\n\n    function Person(name, age, job){\n        this.name = name;\n        this.age = age;\n        this.job = job;\n    }\n\n    Person.prototype = {\n        constructor: Person,\n        sayName: function(){\n            alert(this.name);\n        }\n    }\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    var person2 = new createPerson(\"kobe\"，9，\"student\");\n\n    console.log(person1.name); // \"james\"\n    console.log(person2.name); // \"kobe\"\n    console.log(person1.sayName === person2.sayName); // true\n\n\n### 5.动态原型模式\n把所有信息都封装在构造函数里，通过判断只初始化一次原型\n\n优点：解决了混合模式中封装性的问题\n\n    function Person(name, age, job){\n        this.name = name;\n        this.age = age;\n        this.job = job;\n\n        if(typeof this.sayName !== \"function\" ){\n\n            Person.prototype.sayName: function(){\n                alert(this.name);\n            } \n        } \n    }\n\n    var person1 = new createPerson(\"james\"，9，\"student\");\n\n    person1.sayName(); // \"james\"\n\n### 6.稳妥构造函数模式\n和工厂模式一样的创建，但是采用new操作符最后来创建对象\n\n优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。\n\n缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。\n\n    function Person(name, age, job){\n        var o = new Object();\n        o.name = name;\n        o.age = age;\n        o.job = job;\n        o.sayName = function(){\n            alert(this.name);\n        };\n        return o;\n    }\n\n    var person1 = new Person(\"james\"，9，\"student\");\n\n### 7.稳妥构造函数模式\n稳妥对象，既没有公共属性，而且其方法也不使用this的对象，比较封闭，防止数据修改\n\n优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。\n\n缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型\n\n    function Person(name, age, job){\n\n        //创建要返回的对象\n        var o = new Object();\n\n        //可以在这里定义私有变量和函数\n\n        //添加方法\n        o.sayName = function(){\n            console.log(this.name);\n        }\n\n        //返回对象\n        return o;\n    } \n\n    var person1 =  Person(\"james\"，9，\"student\");\n\n    person1.sayName(); // \"james\"","date":"2023-09-16T10:05:50.837Z","updated":"2023-09-16T10:05:50.837Z","path":"study/Javascript/js创建对象的方法.html","title":"","comments":1,"layout":"page","_id":"clmlv9h8e0009cwun2w5996lk","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>title: 杂记<br>author: 白无意<br>tags:</p>\n<ul>\n<li>Javascript<br>categories:</li>\n<li>Javascript<br>date: 2022-8-05</li>\n</ul>\n<h2 id=\"js创建对象的方法\"><a href=\"#js创建对象的方法\" class=\"headerlink\" title=\"js创建对象的方法\"></a>js创建对象的方法</h2><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：</p>\n<h3 id=\"1-工厂模式\"><a href=\"#1-工厂模式\" class=\"headerlink\" title=\"1.工厂模式\"></a>1.工厂模式</h3><p>用函数来封装对象的细节</p>\n<p>优点：解决创建多个相似对象代码复用的问题</p>\n<p>缺点：没有解决对象识别问题（不知道这个对象是谁</p>\n<pre><code class=\"hljs\">function createPerson(name, age, job)&#123;\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n    return o;\n&#125;\n\nvar person1 = createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"2-构造函数模式\"><a href=\"#2-构造函数模式\" class=\"headerlink\" title=\"2.构造函数模式\"></a>2.构造函数模式</h3><p>当我们使用构造函数实例化一个对象的时候，对象中会包含一个 <strong>proto</strong> 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。</p>\n<p>优点：解决了对象类型无法识别的问题，<br>缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</p>\n<pre><code class=\"hljs\">function createPerson(name, age, job)&#123;\nthis.name = name;\nthis.age = age;\nthis.job = job;\nthis.sayName = function()&#123;\n    alert(this.name);\n&#125;;\nreturn o;\n</code></pre>\n<p>}</p>\n<pre><code class=\"hljs\">var person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = new createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"3-原型模式\"><a href=\"#3-原型模式\" class=\"headerlink\" title=\"3.原型模式\"></a>3.原型模式</h3><p>每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。</p>\n<p>优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。</p>\n<p>缺点：</p>\n<p>首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。</p>\n<p>因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。</p>\n<pre><code class=\"hljs\">function Person()&#123;\n\n&#125;\n\nPerson.prototype.name = &quot;james&quot;;\nPerson.prototype.age = 9;\nPerson.prototype.job = &quot;student&quot;;\nPerson.prototype.sayName = function()&#123;\n    alert(this.name);\n&#125;\n\nvar person1 = new Person();\nperson1.sayName(); // &quot;james&quot;\n\nvar person2 = new Person();\nperson2.sayName(); // &quot;james&quot;\n\n\nconsole.log(person1.sayName === person2.sayName) // true\n</code></pre>\n<h3 id=\"4-组合使用构造函数模式和原型模式\"><a href=\"#4-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"4.组合使用构造函数模式和原型模式\"></a>4.组合使用构造函数模式和原型模式</h3><p>用构造函数船舰对象，原型模式创建方法</p>\n<p>优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。</p>\n<p>缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。</p>\n<pre><code class=\"hljs\">function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n&#125;\n\nPerson.prototype = &#123;\n    constructor: Person,\n    sayName: function()&#123;\n        alert(this.name);\n    &#125;\n&#125;\n\nvar person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = new createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n\nconsole.log(person1.name); // &quot;james&quot;\nconsole.log(person2.name); // &quot;kobe&quot;\nconsole.log(person1.sayName === person2.sayName); // true\n</code></pre>\n<h3 id=\"5-动态原型模式\"><a href=\"#5-动态原型模式\" class=\"headerlink\" title=\"5.动态原型模式\"></a>5.动态原型模式</h3><p>把所有信息都封装在构造函数里，通过判断只初始化一次原型</p>\n<p>优点：解决了混合模式中封装性的问题</p>\n<pre><code class=\"hljs\">function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n\n    if(typeof this.sayName !== &quot;function&quot; )&#123;\n\n        Person.prototype.sayName: function()&#123;\n            alert(this.name);\n        &#125; \n    &#125; \n&#125;\n\nvar person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nperson1.sayName(); // &quot;james&quot;\n</code></pre>\n<h3 id=\"6-稳妥构造函数模式\"><a href=\"#6-稳妥构造函数模式\" class=\"headerlink\" title=\"6.稳妥构造函数模式\"></a>6.稳妥构造函数模式</h3><p>和工厂模式一样的创建，但是采用new操作符最后来创建对象</p>\n<p>优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。</p>\n<p>缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。</p>\n<pre><code class=\"hljs\">function Person(name, age, job)&#123;\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n    return o;\n&#125;\n\nvar person1 = new Person(&quot;james&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"7-稳妥构造函数模式\"><a href=\"#7-稳妥构造函数模式\" class=\"headerlink\" title=\"7.稳妥构造函数模式\"></a>7.稳妥构造函数模式</h3><p>稳妥对象，既没有公共属性，而且其方法也不使用this的对象，比较封闭，防止数据修改</p>\n<p>优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。</p>\n<p>缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型</p>\n<pre><code class=\"hljs\">function Person(name, age, job)&#123;\n\n    //创建要返回的对象\n    var o = new Object();\n\n    //可以在这里定义私有变量和函数\n\n    //添加方法\n    o.sayName = function()&#123;\n        console.log(this.name);\n    &#125;\n\n    //返回对象\n    return o;\n&#125; \n\nvar person1 =  Person(&quot;james&quot;，9，&quot;student&quot;);\n\nperson1.sayName(); // &quot;james&quot;\n</code></pre>\n","site":{"data":{}},"wordcount":3515,"excerpt":"","more":"<p>title: 杂记<br>author: 白无意<br>tags:</p>\n<ul>\n<li>Javascript<br>categories:</li>\n<li>Javascript<br>date: 2022-8-05</li>\n</ul>\n<h2 id=\"js创建对象的方法\"><a href=\"#js创建对象的方法\" class=\"headerlink\" title=\"js创建对象的方法\"></a>js创建对象的方法</h2><p>我们一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js<br>和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是我们可以使用函数来进行模拟，从而产生出可复用的对象<br>创建方式，我了解到的方式有这么几种：</p>\n<h3 id=\"1-工厂模式\"><a href=\"#1-工厂模式\" class=\"headerlink\" title=\"1.工厂模式\"></a>1.工厂模式</h3><p>用函数来封装对象的细节</p>\n<p>优点：解决创建多个相似对象代码复用的问题</p>\n<p>缺点：没有解决对象识别问题（不知道这个对象是谁</p>\n<pre><code>function createPerson(name, age, job)&#123;\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n    return o;\n&#125;\n\nvar person1 = createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"2-构造函数模式\"><a href=\"#2-构造函数模式\" class=\"headerlink\" title=\"2.构造函数模式\"></a>2.构造函数模式</h3><p>当我们使用构造函数实例化一个对象的时候，对象中会包含一个 <strong>proto</strong> 属性指向构造函数原型对象，而原型对象中则包含一个 constructor 属性指向构造函数。因此在实例对象中我们可以通过原型链来访问到 constructor 属性，从而判断对象的类型。</p>\n<p>优点：解决了对象类型无法识别的问题，<br>缺点：在使用构造函数创建对象时，每个方法都会在实例对象中重新创建一遍。拿上面的例子举例，这意味着每创建一个对象，我们就会创建一个 sayName 函数的实例，但它们其实做的都是同样的工作，因此这样便会造成内存的浪费。</p>\n<pre><code>function createPerson(name, age, job)&#123;\nthis.name = name;\nthis.age = age;\nthis.job = job;\nthis.sayName = function()&#123;\n    alert(this.name);\n&#125;;\nreturn o;\n</code></pre>\n<p>}</p>\n<pre><code>var person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = new createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"3-原型模式\"><a href=\"#3-原型模式\" class=\"headerlink\" title=\"3.原型模式\"></a>3.原型模式</h3><p>每一个函数都有一个 prototype 属性，这个属性指向函数的原型对象，这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。我们通过使用原型对象可以让所有的对象实例共享它所包含的属性和方法，因此这样也解决了代码的复用问题。</p>\n<p>优点：解决了构造函数模式中多次创建相同函数对象的问题，所有的实例可以共享同一组属性和函数。</p>\n<p>缺点：</p>\n<p>首先第一个问题是原型模式省略了构造函数模式传递初始化参数的过程，所有的实例在默认情况下都会取得默认的属性值，会在一定程度上造成不方便。</p>\n<p>因为所有的实例都是共享一组属性，对于包含基本值的属性来说没有问题，但是对于包含引用类型的值来说（例如数组对象），所有的实例都是对同一个引用类型进行操作，那么属性的操作就不是独立的，最后导致读写的混乱。我们创建的实例一般都是要有属于自己的全部属性的，因此单独使用原型模式的情况是很少存在的。</p>\n<pre><code>function Person()&#123;\n\n&#125;\n\nPerson.prototype.name = &quot;james&quot;;\nPerson.prototype.age = 9;\nPerson.prototype.job = &quot;student&quot;;\nPerson.prototype.sayName = function()&#123;\n    alert(this.name);\n&#125;\n\nvar person1 = new Person();\nperson1.sayName(); // &quot;james&quot;\n\nvar person2 = new Person();\nperson2.sayName(); // &quot;james&quot;\n\n\nconsole.log(person1.sayName === person2.sayName) // true\n</code></pre>\n<h3 id=\"4-组合使用构造函数模式和原型模式\"><a href=\"#4-组合使用构造函数模式和原型模式\" class=\"headerlink\" title=\"4.组合使用构造函数模式和原型模式\"></a>4.组合使用构造函数模式和原型模式</h3><p>用构造函数船舰对象，原型模式创建方法</p>\n<p>优点：采用了构造函数模式和原型模式的优点，这种混成模式是目前使用最广泛，认同度最高的一种创建自定类型的方法。</p>\n<p>缺点：由于使用了两种模式，因此对于代码的封装性来说不是很好。</p>\n<pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n&#125;\n\nPerson.prototype = &#123;\n    constructor: Person,\n    sayName: function()&#123;\n        alert(this.name);\n    &#125;\n&#125;\n\nvar person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nvar person2 = new createPerson(&quot;kobe&quot;，9，&quot;student&quot;);\n\nconsole.log(person1.name); // &quot;james&quot;\nconsole.log(person2.name); // &quot;kobe&quot;\nconsole.log(person1.sayName === person2.sayName); // true\n</code></pre>\n<h3 id=\"5-动态原型模式\"><a href=\"#5-动态原型模式\" class=\"headerlink\" title=\"5.动态原型模式\"></a>5.动态原型模式</h3><p>把所有信息都封装在构造函数里，通过判断只初始化一次原型</p>\n<p>优点：解决了混合模式中封装性的问题</p>\n<pre><code>function Person(name, age, job)&#123;\n    this.name = name;\n    this.age = age;\n    this.job = job;\n\n    if(typeof this.sayName !== &quot;function&quot; )&#123;\n\n        Person.prototype.sayName: function()&#123;\n            alert(this.name);\n        &#125; \n    &#125; \n&#125;\n\nvar person1 = new createPerson(&quot;james&quot;，9，&quot;student&quot;);\n\nperson1.sayName(); // &quot;james&quot;\n</code></pre>\n<h3 id=\"6-稳妥构造函数模式\"><a href=\"#6-稳妥构造函数模式\" class=\"headerlink\" title=\"6.稳妥构造函数模式\"></a>6.稳妥构造函数模式</h3><p>和工厂模式一样的创建，但是采用new操作符最后来创建对象</p>\n<p>优点：我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。</p>\n<p>缺点：和工厂模式一样的问题，不能依赖 instanceof 操作符来确定对象的类型。</p>\n<pre><code>function Person(name, age, job)&#123;\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function()&#123;\n        alert(this.name);\n    &#125;;\n    return o;\n&#125;\n\nvar person1 = new Person(&quot;james&quot;，9，&quot;student&quot;);\n</code></pre>\n<h3 id=\"7-稳妥构造函数模式\"><a href=\"#7-稳妥构造函数模式\" class=\"headerlink\" title=\"7.稳妥构造函数模式\"></a>7.稳妥构造函数模式</h3><p>稳妥对象，既没有公共属性，而且其方法也不使用this的对象，比较封闭，防止数据修改</p>\n<p>优点：以上面为例，除了 sayName 方法外，没有别的方法可以访问数据成员，这就是稳妥构造函数提供的安全性。</p>\n<p>缺点：和寄生构造函数一样，没有办法使用 instanceof 操作符来判断对象的类型</p>\n<pre><code>function Person(name, age, job)&#123;\n\n    //创建要返回的对象\n    var o = new Object();\n\n    //可以在这里定义私有变量和函数\n\n    //添加方法\n    o.sayName = function()&#123;\n        console.log(this.name);\n    &#125;\n\n    //返回对象\n    return o;\n&#125; \n\nvar person1 =  Person(&quot;james&quot;，9，&quot;student&quot;);\n\nperson1.sayName(); // &quot;james&quot;\n</code></pre>\n"},{"title":"前端","date":"2022-07-14T05:30:51.000Z","_content":"\n你好","source":"study/index.md","raw":"---\ntitle: 前端\ndate: 2022-07-14 13:30:51\n---\n\n你好","updated":"2024-07-31T08:14:15.171Z","path":"study/index.html","comments":1,"layout":"page","_id":"clz9kucnn000098undjz47yx9","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><p>你好</p>\n","site":{"data":{}},"wordcount":2,"excerpt":"","more":"<p>你好</p>\n"}],"Post":[{"title":"test","date":"2022-08-10T15:35:53.000Z","_content":"","source":"_posts/test-1.md","raw":"---\ntitle: test\ndate: 2022-08-10 23:35:53\ntags:\n---\n","slug":"test-1","published":1,"updated":"2023-09-16T10:05:50.828Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clmlv9h7s0001cwun5ie7bx18","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>","site":{"data":{}},"wordcount":0,"excerpt":"","more":""},{"title":"杂记","author":"白无意","date":"2022-06-14T02:31:00.000Z","_content":"## 杂记\n### 一.写在前面\n```\n \n    在未来的日子里向着前端开发工程师这个目标前进（赶紧找个班上吧）\n```\n<!-- 你好，我是白无意，回想过去，我一直在找自己的可能，逐渐往着斜杠青年的方向发展，于是乎，大部分东西我都有所涉猎，但不会到精通的地步，一方面，我是个十分懒惰的人，加之我急于求成的性格，大部分时候我都没有沉稳下来去加深学习，没有长久的沉淀，于是没有丝毫的闪光点，即使在外人看来我好像什么都会。\n    同时，我又是个十分幼稚的人,我总会幻想很多可能，我总会觉得很多事情是理所应当的，我上了大学能遇到她，我毕业了能找到喜欢的工作。我总是真诚的对待每一个人，我总是在乎别人的感受，我总是在揣测别人的想法，我真的很累，逐渐的，我丝毫没有在意我自己的事情。\n    很多时候事情都不能如人们所愿的吧，我过的并不好。我要思考，我要进步，我想要好生活。 -->\n### 二.关于这个网站\n其实在上大学前就有过构建自己个人网站的想法，但一直没有付诸行动，在临近毕业，为了找工作疯狂学习，闲暇之余就看到了这个框架,在今后的日子里，这个网站会成为我的日记本\n```\n（正经人谁写日记啊？小声bb）\n```\n\n我的前端学习笔记，我的杂记，我的摄影集 and so on.....\n\n### 2022-07-14\n今天计划把[旧博客](https://br1-blog-br1nosense.vercel.app/)搬到Hexo的新博客当中","source":"_posts/test.md","raw":"title: 杂记\nauthor: 白无意\ntags:\n  - 日记\ncategories:\n  - 日记\ndate: 2022-06-14 10:31:00\n---\n## 杂记\n### 一.写在前面\n```\n \n    在未来的日子里向着前端开发工程师这个目标前进（赶紧找个班上吧）\n```\n<!-- 你好，我是白无意，回想过去，我一直在找自己的可能，逐渐往着斜杠青年的方向发展，于是乎，大部分东西我都有所涉猎，但不会到精通的地步，一方面，我是个十分懒惰的人，加之我急于求成的性格，大部分时候我都没有沉稳下来去加深学习，没有长久的沉淀，于是没有丝毫的闪光点，即使在外人看来我好像什么都会。\n    同时，我又是个十分幼稚的人,我总会幻想很多可能，我总会觉得很多事情是理所应当的，我上了大学能遇到她，我毕业了能找到喜欢的工作。我总是真诚的对待每一个人，我总是在乎别人的感受，我总是在揣测别人的想法，我真的很累，逐渐的，我丝毫没有在意我自己的事情。\n    很多时候事情都不能如人们所愿的吧，我过的并不好。我要思考，我要进步，我想要好生活。 -->\n### 二.关于这个网站\n其实在上大学前就有过构建自己个人网站的想法，但一直没有付诸行动，在临近毕业，为了找工作疯狂学习，闲暇之余就看到了这个框架,在今后的日子里，这个网站会成为我的日记本\n```\n（正经人谁写日记啊？小声bb）\n```\n\n我的前端学习笔记，我的杂记，我的摄影集 and so on.....\n\n### 2022-07-14\n今天计划把[旧博客](https://br1-blog-br1nosense.vercel.app/)搬到Hexo的新博客当中","slug":"test","published":1,"updated":"2023-09-16T10:18:19.846Z","_id":"clmlv9h810003cwungndu9b8q","comments":1,"layout":"post","photos":[],"link":"","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script><h2 id=\"杂记\"><a href=\"#杂记\" class=\"headerlink\" title=\"杂记\"></a>杂记</h2><h3 id=\"一-写在前面\"><a href=\"#一-写在前面\" class=\"headerlink\" title=\"一.写在前面\"></a>一.写在前面</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\"> <br>在未来的日子里向着前端开发工程师这个目标前进（赶紧找个班上吧）<br></code></pre></td></tr></table></figure>\n<!-- 你好，我是白无意，回想过去，我一直在找自己的可能，逐渐往着斜杠青年的方向发展，于是乎，大部分东西我都有所涉猎，但不会到精通的地步，一方面，我是个十分懒惰的人，加之我急于求成的性格，大部分时候我都没有沉稳下来去加深学习，没有长久的沉淀，于是没有丝毫的闪光点，即使在外人看来我好像什么都会。\n    同时，我又是个十分幼稚的人,我总会幻想很多可能，我总会觉得很多事情是理所应当的，我上了大学能遇到她，我毕业了能找到喜欢的工作。我总是真诚的对待每一个人，我总是在乎别人的感受，我总是在揣测别人的想法，我真的很累，逐渐的，我丝毫没有在意我自己的事情。\n    很多时候事情都不能如人们所愿的吧，我过的并不好。我要思考，我要进步，我想要好生活。 -->\n<h3 id=\"二-关于这个网站\"><a href=\"#二-关于这个网站\" class=\"headerlink\" title=\"二.关于这个网站\"></a>二.关于这个网站</h3><p>其实在上大学前就有过构建自己个人网站的想法，但一直没有付诸行动，在临近毕业，为了找工作疯狂学习，闲暇之余就看到了这个框架,在今后的日子里，这个网站会成为我的日记本</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">（正经人谁写日记啊？小声bb）<br></code></pre></td></tr></table></figure>\n\n<p>我的前端学习笔记，我的杂记，我的摄影集 and so on…..</p>\n<h3 id=\"2022-07-14\"><a href=\"#2022-07-14\" class=\"headerlink\" title=\"2022-07-14\"></a>2022-07-14</h3><p>今天计划把<a href=\"https://br1-blog-br1nosense.vercel.app/\">旧博客</a>搬到Hexo的新博客当中</p>\n","site":{"data":{}},"wordcount":205,"excerpt":"","more":"<h2 id=\"杂记\"><a href=\"#杂记\" class=\"headerlink\" title=\"杂记\"></a>杂记</h2><h3 id=\"一-写在前面\"><a href=\"#一-写在前面\" class=\"headerlink\" title=\"一.写在前面\"></a>一.写在前面</h3><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\"> <br>在未来的日子里向着前端开发工程师这个目标前进（赶紧找个班上吧）<br></code></pre></td></tr></table></figure>\n<!-- 你好，我是白无意，回想过去，我一直在找自己的可能，逐渐往着斜杠青年的方向发展，于是乎，大部分东西我都有所涉猎，但不会到精通的地步，一方面，我是个十分懒惰的人，加之我急于求成的性格，大部分时候我都没有沉稳下来去加深学习，没有长久的沉淀，于是没有丝毫的闪光点，即使在外人看来我好像什么都会。\n    同时，我又是个十分幼稚的人,我总会幻想很多可能，我总会觉得很多事情是理所应当的，我上了大学能遇到她，我毕业了能找到喜欢的工作。我总是真诚的对待每一个人，我总是在乎别人的感受，我总是在揣测别人的想法，我真的很累，逐渐的，我丝毫没有在意我自己的事情。\n    很多时候事情都不能如人们所愿的吧，我过的并不好。我要思考，我要进步，我想要好生活。 -->\n<h3 id=\"二-关于这个网站\"><a href=\"#二-关于这个网站\" class=\"headerlink\" title=\"二.关于这个网站\"></a>二.关于这个网站</h3><p>其实在上大学前就有过构建自己个人网站的想法，但一直没有付诸行动，在临近毕业，为了找工作疯狂学习，闲暇之余就看到了这个框架,在今后的日子里，这个网站会成为我的日记本</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs\">（正经人谁写日记啊？小声bb）<br></code></pre></td></tr></table></figure>\n\n<p>我的前端学习笔记，我的杂记，我的摄影集 and so on…..</p>\n<h3 id=\"2022-07-14\"><a href=\"#2022-07-14\" class=\"headerlink\" title=\"2022-07-14\"></a>2022-07-14</h3><p>今天计划把<a href=\"https://br1-blog-br1nosense.vercel.app/\">旧博客</a>搬到Hexo的新博客当中</p>\n"},{"layout":"photo","title":"zhuhai","date":"2022-08-10T15:56:35.000Z","_content":"","source":"_posts/zhuhai.md","raw":"---\nlayout: photo\ntitle: zhuhai\ndate: 2022-08-10 23:56:35\ntags: 珠海\n---\n","slug":"zhuhai","published":1,"updated":"2023-09-16T10:05:50.828Z","comments":1,"photos":[],"link":"","_id":"clmlv9h850005cwun4j3a4orv","content":"<link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"\\assets\\css\\APlayer.min.css\"><script src=\"\\assets\\js\\APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"\\assets\\js\\Meting.min.js\"></script>","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"clmlv9h810003cwungndu9b8q","category_id":"clmlv9h890006cwun515v98io","_id":"clmlv9h8h000ccwunatrzcd07"}],"PostTag":[{"post_id":"clmlv9h810003cwungndu9b8q","tag_id":"clmlv9h8b0007cwunfqyi38h7","_id":"clmlv9h8g000bcwun8ln54bia"},{"post_id":"clmlv9h850005cwun4j3a4orv","tag_id":"clmlv9h8f000acwun1v6xahto","_id":"clmlv9h8h000dcwun0utr7qs0"}],"Tag":[{"name":"日记","_id":"clmlv9h8b0007cwunfqyi38h7"},{"name":"珠海","_id":"clmlv9h8f000acwun1v6xahto"}]}}